||| Copyright (C) 1998-2009, Sumisho Computer Systems Corp. All Rights Reserved.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
|||
|||     http://www.apache.org/licenses/LICENSE-2.0
|||
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.

|||
||| @authors Hiroshi Miyazaki
|||

{curl-file-attributes character-encoding = "shift-jis"}

{doc-next
    {purpose 行列演算を行うクラス}
    {parameter t , 行列の要素の型を指定する。 }
    {details 
        {itemize    }
        {itemize クラス名　:　Matrix-of   }
        {itemize パラメタ 　:　t:NumericType　任意の数値型を指定できる。int、double等。　　　　}
        {itemize    パラメタに指定された型の行列を作成する。}
        {itemize 以下の行列演算メソッド、プロシージャを持つ。}
        {itemize    }
        {itemize ・get-column}
        {itemize ・get-row}
        {itemize ・transpose}
        {itemize ・get-sub-matrix}
        {itemize ・normalize}
        {itemize ・scalar-add}
        {itemize ・scalar-multiple}
        {itemize ・add-matrix}
        {itemize ・subtract-matrix}
        {itemize ・inverse}
        {itemize ・multiple}
        {itemize    }
        {itemize Array-2-ofの　行列を継承しているので、そちらのヘルプも参照。}
        {itemize インスタンス生成時には、ｍ×ｎ行列としてｍ、ｎを指定する必要がある。}
    }
}  
{define-class public open {Matrix-of t:NumericType} 
  {inherits {Array-2-of t}}
  
  {constructor public {default
                          row:int,     ||行
                          column:int,  ||列
                          ...:t
                      }
    {construct-super row, column}  
    || TODO: set self[i][j] = ...
    || 行列を０で初期化する。
  }
  {doc-next
    {purpose 行列の指定された列を取り出すメソッド }
    {parameter i , 列を指定するint型の整数 }
    {return-vals ＃ FastArray-of型の配列 }
    {details 
        {itemize }
        {itemize ・　パラメタ　i　の列の値をすべて返す。  }
    }
  }
  {method public {get-column i:int}:#{FastArray-of t}
    let (y:int, x:int) = {self.size}
    let column-array-i:#{FastArray-of double} = {new {FastArray-of double}, max-size = y}
    {for j:int = 0 below y do
        def num = self[j,i]
        {column-array-i.append num}
    }  
    {return column-array-i }
  }
  {doc-next
    {purpose 行列の指定された行を取り出すメソッド }
    {parameter i , 行を指定するint型の整数 }
    {return-vals ＃ FastArray-of型の配列 }
    {details 
        {itemize }
        {itemize ・　パラメタ　i　の行の値をすべて返す。  }
    }
  }
  {method public {get-row i:int}:#{FastArray-of t}
    let (y:int, x:int) = {self.size}
    let row-array-i:#{FastArray-of double} = {new {FastArray-of double}, max-size = x}
    {for j:int = 0 below x do
        def num = self[i,j]
        {row-array-i.append num}
    }  
    {return row-array-i }  
  }
  {doc-next
    {purpose 転置行列を返すメソッド }
    {return-vals ＃ Matrix-of型の行列 }
    {details 
        {itemize }
        {itemize ・　行列を転置し、転置した行列を返す。 }
    }
  }
  {method public open {transpose}:#{Matrix-of double}
    let (y:int, x:int) = {self.size}
    {let my-matrix-trans:#{Matrix-of double} = 
        {new {Matrix-of double} ,x,y } } || 転置するから、Xと Yは逆にすべき
    {for j=0 below x do
        {for i=0 below y do
          set my-matrix-trans[j,i]  = self[i,j]    
        }
    }
    {return my-matrix-trans}        
  }
  {doc-next
    {purpose 大きな行列の中から、小さな行列をサブ行列として取り出すメソッド }
    {parameter start-row 　　　, 取り出す行の開始位置を指定するint型の整数 }
    {parameter end-row 　　　　  , 取り出す行の終了位置を指定するint型の整数 }
    {parameter start-column , 取り出す列の開始位置を指定するint型の整数 }
    {parameter end-column 　　, 取り出す列の終了位置を指定するint型の整数 }
    {return-vals  ＃ Matrix-of型の行列 }
    {details 
        {itemize }
        {itemize ・　大きな行列から小さな行列を取り出すメソッド。  }
        {itemize }
        {itemize 　例：　３かける３の行列 A　から、 ２かける２の行列　Bを取り出すメソッド }
        {itemize 　　　　"　　　  １　２　３　　　　　　５　６　"　　　　　}
        {itemize 　　　　"A　=　４　５　６　　　B = ８　９"　　　　　　}
        {itemize 　　　　"　　　  ７　８　９"　　　　　　　　　　　　　　　 }
        {itemize 　　　　　　　　　　　　　　　　　　　　　　　　　　}
    }
  }  
  {method public open {get-sub-matrix
                     start-row:int,
                     end-row:int,
                     start-column:int,
                     end-column:int
                 }:#{Matrix-of double}
    let row-length:int = end-row - start-row +1
    let column-length:int = end-column - start-column +1
    {let sub-matrix:#{Matrix-of double} = 
        {new {Matrix-of double} ,column-length,row-length } }
    let h:int = 0
    let i:int = 0
    {for s-row:int = start-row to end-row do
        {for s-column:int = start-column to end-column do
            set sub-matrix[h,i] = self[s-row,s-column]
            {inc i} 
        }
        set i = 0
        {inc h}
    }
    {return sub-matrix}
  }  
  {doc-next
    {purpose 行列を正規化して取り出すメソッド }
    {return-vals ＃ Matrix-of型の配列 }
    {details 
        {itemize }
        {itemize ・　行列を正規化し、その値を設定した行列を返すメソッド。  }
    }
  }
  {method public inline {normalize}:#{Matrix-of double}
    let (y:int, x:int) = {self.size}
    let normalize-matrix:#{Matrix-of double} = {new {Matrix-of double} ,y,x }
    let total:double = 0
    let i:int = 0
    let k:int = 0
    {for i = 0 below y do
        let array-row:#{FastArray-of double} = {self.get-row i}
        {for k = 0 below x do 
            let squares:double = array-row[k] * array-row[k]
            set total = total + squares
            let nomalize-coefficient:double = {sqrt total}
            set normalize-matrix[i,k] = self[i,k] / nomalize-coefficient
        }
        set k = 0
    }    
    {return normalize-matrix}
  }
  {doc-next
    {purpose 行列の全要素にスカラー量を加算するメソッド}
    {parameter scalar , 行列の全要素に加算する double型の数 }
    {return-vals ＃ Matrix-of型の行列 }
    {details 
        {itemize }
        {itemize ・　 行列の全要素にパラメタ(scalar)のスカラー量を加算する。}
    }
  }  
  {method public inline {scalar-add
                        scalar:double    
                        }:#{Matrix-of double}
    let (y:int, x:int) = {self.size}
    {for i:int = 0 below y do
        {for j:int = 0 below x do
        set self[i,j] = self[i,j] + scalar    
        }    
    }
    {return self}
  }
  {doc-next
    {purpose 行列の全要素にスカラー量を乗算するメソッド}
    {parameter scalar , 行列の全要素に乗算する double型の数 }
    {return-vals ＃ Matrix-of型の行列 }
    {details 
        {itemize }
        {itemize ・　 行列の全要素にパラメタ(scalar)のスカラー量を乗算する。}
    }
  }
  {method public inline {scalar-multiple
                            scalar:double    
                        }:#{Matrix-of double}
    let (y:int, x:int) = {self.size}
    {for i:int = 0 below y do
        {for j:int = 0 below x do
            set self[i,j] = self[i,j] * scalar    
        }    
    }
    {return self}
  }
}
{doc-next
    {purpose ２つの行列をパラメタに指定し、その行列の値を加算するプロシージャ}
    {parameter m1 , 加算したい行列　１ }
    {parameter m2 , 加算したい行列　２ }
    {return-vals ＃ Matrix-of型の行列 }
    {details 
        {itemize }
        {itemize ・　 ｍ１とｍ２を加算した結果を返す行列。}
    }
}  
{define-proc public inline {add-matrix 
                               m1:#{Matrix-of double}, 
                               m2:#{Matrix-of double}
                           }:#{Matrix-of double}
    let (y:int, x:int) = {m1.size}
    let (y1:int, x1:int) = {m2.size}
    {if y < y1 then 
        set y = y1
    }
    {if x < x1 then 
        set x = x1
    }
    {let total:#{Matrix-of double} = 
        {new {Matrix-of double} ,y,x } }　|| m1と m2のうち、縦 、 横、　共に大きい方の値が必要。
    {for j:int = 0 below y do
        {for i:int = 0 below x do
            set total[j,i] = m1[j,i] + m2[j,i]
        }
    }
    {return total}
}
{doc-next
    {purpose ２つの行列をパラメタに指定し、その行列の値を減算するプロシージャ}
    {parameter m1 , 減算される行列　１ }
    {parameter m2 , 減算したい行列　２ }
    {return-vals ＃ Matrix-of型の行列 }
    {details 
        {itemize }
        {itemize ・　 ｍ１　-　ｍ２　の　結果を返す行列。}
    }
}  
{define-proc public inline {subtract-matrix 
                               m1:#{Matrix-of double},
                               m2:#{Matrix-of double}
                           }:#{Matrix-of double}
    || TODO
    || 行列同士の引き算を行う。
    let (y:int, x:int) = {m1.size}
    let (y2:int, x2:int) = {m2.size}
    {if y < y2 then 
        set y = y2
    }
    {if x < x2 then 
        set x = x2
    }
    {let total:#{Matrix-of double} = 
        {new {Matrix-of double} ,y,x } }　|| m1と m2のうち、縦 、 横、　共に大きい方の値が必要。
    {for j:int = 0 below y do
        {for i:int = 0 below x do
            set total[j,i] = m1[j,i] - m2[j,i]
        }
    }
    {return total}
}  
{doc-next
    {purpose 行列をパラメタに指定し、その逆行列の値を返すプロシージャ}
    {parameter m1 , 逆行列がほしい行列を指定する }
    {return-vals ＃ Matrix-of型の行列 }
    {details 
        {itemize }
        {itemize ・　 ｍ１の逆行列を返す。}
    }
}  
{define-proc public inline {inverse
                               m1:#{Matrix-of double}
                           }:#{Matrix-of double}
    let (x1:int, y1:int) = {m1.size}
    {if x1 != y1 then
        {error "正方行列ではないため、逆行列は存在しません。inverseの後に指定した行列の次数を確認してください。" }
    }
    let buf:double　|| 作業域、掃き出し法で使用する係数。
    let i:int      ||  i , j ,k はカウンタ
    let j:int      
    let k:int      
    {let inv-matrix:#{Matrix-of double} = 
        {new {Matrix-of double} ,y1,x1 } }
    def n = x1 || n 次元の正方行列。　正方行列なので、rowでもcolumnでもどちらでもよい。
    || 逆行列を入れるための器を作成し、これを返す。
    || 掃き出し法で必要となるため、単位行列で初期化しておく。
    {for i = 0 below n do
        {for j = 0 below n do
            {if i == j then
                set inv-matrix[i,j] = 1.0
             else
                set inv-matrix[i,j] = 0.0
            }
        }
    }
    || 掃き出し法
    {for i = 0 below n do
        set buf = 1 / m1[i,i]
        {for j = 0 below n do
            set m1[i,j] = m1[i,j] * buf
            set inv-matrix[i,j] = inv-matrix[i,j] * buf
        }
        {for j = 0 below n do
            {if i != j then
                set buf = m1[j,i]
                {for k = 0 below n do
                    set m1[j,k] = m1[j,k] - m1[i,k] * buf
                    set inv-matrix[j,k] = inv-matrix[j,k] - inv-matrix[i,k] * buf
                }
            }
        }
    }
    {return inv-matrix}
}
{doc-next
    {purpose ２つの行列をパラメタに指定し、その行列の掛け算の結果を返すプロシージャ}
    {parameter m1 , 掛け算を行いたい行列を指定する }
    {parameter m2 , 掛け算を行いたい行列を指定する }
    {return-vals ＃ Matrix-of型の行列 }
    {details 
        {itemize ｍ２の行列の左からｍ１の行列を掛けたもの。}
        {itemize ・　 ｍ１×ｍ２の行列の演算結果を返す。}
        {itemize パラメタ１の行列 ｘ１＊ｙ１　パラメタ２の行列 ｘ２＊ｙ２とすると、}
        {itemize ｙ１ == x2 でなければなりません。}    
    }
}  
{define-proc public inline {multiple
                               m1:#{Matrix-of double},
                               m2:#{Matrix-of double}
                           }:#{Matrix-of double}
    let (x1:int, y1:int) = {m1.size}
    let (x2:int, y2:int) = {m2.size}
    {if y1 != x2 then 
        {text この行列の組み合わせは、掛け算できません。
            パラメタ１の行列 ｘ１＊ｙ１　
            パラメタ２の行列 ｘ２＊ｙ２とすると、
            ｙ１ == x2 でなければなりません。}
    }
    {let multiple-matrix:#{Matrix-of double} = 
        {new {Matrix-of double} ,x1,y2 } }　
    let i:int
    let j:int
    let k:int
    {for i = 0 below x1 do 
        {for j = 0 below y2 do
            {for k = 0 below y1 do
                set  multiple-matrix[i,j] = multiple-matrix[i,j] + m1[i,k] * m2[k,j]   
            }
        }
    }    
    {return multiple-matrix}
}
